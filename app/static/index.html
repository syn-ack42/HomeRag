<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Local RAG Chat</title>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<style>
body { font-family: system-ui, sans-serif; margin: 2em; }
#botControls { margin-bottom: 1em; }
#botControls select { margin: 0 0.5em; }
#chat {
    border: 1px solid #ccc;
    border-radius: 10px;
    padding: 1em;
    height: 500px;
    overflow-y: scroll;
}
.user { color: blue; margin: .5em 0; }
.bot { color: darkgreen; margin: .5em 0; }
#q { width: 80%; padding: .5em; font-size: 1em; }
</style>
</head>

<body>

<h2>Local RAG Chat</h2>

<div id="botControls">
    <label for="botSelect"><strong>Active Bot:</strong></label>
    <select id="botSelect"></select>
    <button onclick="createBot()">Create Bot</button>
</div>

<div id="chat"></div>

<input id="q" placeholder="Ask something..." />

<hr/>

<h3>Upload File</h3>
<form id="uploadForm">
    <input type="file" name="file" />
    <button type="submit">Upload</button>
</form>

<h3>Upload ZIP</h3>
<form id="zipForm">
    <input type="file" name="file" />
    <button type="submit">Upload ZIP</button>
</form>

<button onclick="rebuild()">Rebuild Index</button>

<hr/>

<h3>Knowledge Base Files</h3>
<ul id="fileList"></ul>
<button onclick="refreshFiles()">Refresh List</button>

<hr/>

<h3>System Prompt</h3>
<textarea id="systemPrompt" style="width:100%;height:150px;"></textarea>
<button onclick="savePrompt()">Save</button>
<button onclick="loadPrompt()">Reload</button>

<script>
const chat = document.getElementById("chat");
const input = document.getElementById("q");
const botSelect = document.getElementById("botSelect");

let history = [];
let currentBotId = null;

input.addEventListener("keydown", e => {
    if (e.key === "Enter") {
        e.preventDefault();
        sendMessage();
    }
});

botSelect.addEventListener("change", async e => {
    await switchBot(e.target.value, { force: true });
});

function appendUser(msg) {
    chat.innerHTML += `<div class="user"><b>You:</b> ${msg}</div>`;
    chat.scrollTop = chat.scrollHeight;
}

function appendTyping() {
    const el = document.createElement("div");
    el.className = "bot";
    el.innerHTML = "<i>Bot is typingâ€¦</i>";
    chat.appendChild(el);
    chat.scrollTop = chat.scrollHeight;
    return el;
}

function appendBotContainer() {
    const el = document.createElement("div");
    el.className = "bot";
    el.innerHTML = "<b>Bot:</b><br>";
    el.rawText = "";
    el.tokenCount = 0;
    chat.appendChild(el);
    chat.scrollTop = chat.scrollHeight;
    return el;
}

function ensureBotSelected() {
    if (!currentBotId) {
        alert("Please create or select a bot first.");
        return false;
    }
    return true;
}

async function sendMessage() {
    if (!ensureBotSelected()) return;

    const q = input.value.trim();
    if (!q) return;

    history.push({ role: "user", content: q });

    appendUser(q);
    input.value = "";

    const typingEl = appendTyping();

    const response = await fetch("/ask_stream", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ q, bot_id: currentBotId })
    });

    if (!response.ok || !response.body) {
        if (typingEl.parentNode) typingEl.remove();
        const text = await response.text();
        const errorEl = document.createElement("div");
        errorEl.className = "bot";
        const message = text || response.statusText || "Error communicating with the bot.";
        errorEl.innerHTML = `<b>Bot:</b><br><i>${message}</i>`;
        chat.appendChild(errorEl);
        chat.scrollTop = chat.scrollHeight;
        return;
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buf = "";

    const botContainer = appendBotContainer();

    while (true) {
        const { value, done } = await reader.read();
        if (done) break;

        buf += decoder.decode(value, {stream:true});
        const lines = buf.split("\n");
        buf = lines.pop();

        for (let ln of lines) {
            if (!ln.trim()) continue;

            const event = JSON.parse(ln);

            if (typingEl.parentNode) typingEl.remove();

            if (event.type === "token") {
                botContainer.rawText += event.token;
                botContainer.tokenCount++;

                if (botContainer.tokenCount % 5 === 0) {
                    botContainer.innerHTML =
                        "<b>Bot:</b><br>" +
                        marked.parse(botContainer.rawText);
                    chat.scrollTop = chat.scrollHeight;
                }
            }
        }
    }

    botContainer.innerHTML =
        "<b>Bot:</b><br>" +
        marked.parse(botContainer.rawText);
    chat.scrollTop = chat.scrollHeight;

    history.push({ role: "assistant", content: botContainer.rawText });
}

document.getElementById("uploadForm").onsubmit = async e => {
    e.preventDefault();
    if (!ensureBotSelected()) return;
    const form = new FormData(e.target);
    await fetch(`/bots/${currentBotId}/upload`, { method: "POST", body: form });
    alert("Uploaded");
    refreshFiles();
};

document.getElementById("zipForm").onsubmit = async e => {
    e.preventDefault();
    if (!ensureBotSelected()) return;
    const form = new FormData(e.target);
    await fetch(`/bots/${currentBotId}/upload_zip`, { method: "POST", body: form });
    alert("ZIP uploaded");
    refreshFiles();
};

async function rebuild() {
    if (!ensureBotSelected()) return;
    await fetch(`/bots/${currentBotId}/rebuild`, { method: "POST" });
    alert("Reindexed!");
}

async function refreshFiles() {
    if (!currentBotId) {
        document.getElementById("fileList").innerHTML = "";
        return;
    }

    const r = await fetch(`/bots/${currentBotId}/files`);
    const data = await r.json();
    const list = document.getElementById("fileList");
    list.innerHTML = "";

    data.files.forEach(f => {
        const li = document.createElement("li");
        li.textContent = f + " ";
        const btn = document.createElement("button");
        btn.textContent = "Delete";
        btn.onclick = () => deleteFileKB(f);
        li.appendChild(btn);
        list.appendChild(li);
    });
}

async function deleteFileKB(name) {
    if (!ensureBotSelected()) return;
    await fetch(`/bots/${currentBotId}/file/${encodeURIComponent(name)}`, { method: "DELETE" });
    alert("Deleted " + name);
    refreshFiles();
}

async function loadPrompt() {
    if (!currentBotId) {
        document.getElementById("systemPrompt").value = "";
        return;
    }
    const r = await fetch(`/bots/${currentBotId}/prompt`);
    const data = await r.json();
    document.getElementById("systemPrompt").value = data.prompt;
}

async function savePrompt() {
    if (!ensureBotSelected()) return;
    const txt = document.getElementById("systemPrompt").value;
    await fetch(`/bots/${currentBotId}/prompt`, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ prompt: txt })
    });
    alert("Saved");
}

async function loadBots() {
    const r = await fetch("/bots");
    const data = await r.json();

    botSelect.innerHTML = "";

    data.bots.forEach(bot => {
        const option = document.createElement("option");
        option.value = bot.id;
        option.textContent = bot.name;
        botSelect.appendChild(option);
    });

    botSelect.disabled = data.bots.length === 0;

    if (!data.bots.length) {
        await switchBot(null);
        return;
    }

    if (!currentBotId || !data.bots.some(bot => bot.id === currentBotId)) {
        currentBotId = data.bots[0].id;
    }

    botSelect.value = currentBotId;
    await switchBot(currentBotId, { force: true });
}

async function switchBot(id, { force = false } = {}) {
    const promptBox = document.getElementById("systemPrompt");
    const fileList = document.getElementById("fileList");

    if (!id) {
        currentBotId = null;
        history = [];
        chat.innerHTML = "<div class=\"bot\"><i>No bots available. Create one to begin.</i></div>";
        promptBox.value = "";
        fileList.innerHTML = "";
        return;
    }

    if (!force && id === currentBotId) {
        await Promise.all([loadPrompt(), refreshFiles()]);
        return;
    }

    currentBotId = id;
    if (botSelect.value !== id) {
        botSelect.value = id;
    }

    history = [];
    chat.innerHTML = "";
    await Promise.all([loadPrompt(), refreshFiles()]);
}

async function createBot() {
    const name = prompt("Name for the new bot:");
    if (!name || !name.trim()) return;

    const promptText = prompt("Optional system prompt (leave blank for default):", "");
    const payload = { name: name.trim() };
    if (promptText !== null && promptText.trim() !== "") {
        payload.prompt = promptText;
    }

    const res = await fetch("/bots", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload)
    });

    if (!res.ok) {
        let detail = res.statusText;
        try {
            const err = await res.json();
            detail = err.detail || detail;
        } catch (e) {}
        alert("Failed to create bot: " + detail);
        return;
    }

    const data = await res.json();
    currentBotId = data.bot.id;
    await loadBots();
    alert(`Created bot "${data.bot.name}"`);
}

loadBots();
</script>

</body>
</html>

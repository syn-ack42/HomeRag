<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Local RAG Chat</title>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<style>
:root {
    --bg: #f5f7fb;
    --panel: #ffffff;
    --border: #dce2ec;
    --primary: #2563eb;
    --text-muted: #5f6b7a;
}

* { box-sizing: border-box; }
body {
    font-family: "Inter", system-ui, -apple-system, sans-serif;
    margin: 0;
    padding: 0;
    background: var(--bg);
    color: #0f172a;
}

header {
    padding: 1.5rem 2rem 0.5rem;
}

h1 {
    margin: 0 0 0.25rem;
    font-size: 1.8rem;
}

.subtitle {
    color: var(--text-muted);
    margin: 0;
}

.main {
    display: grid;
    grid-template-columns: minmax(0, 70%) minmax(320px, 30%);
    gap: 1rem;
    padding: 0 2rem 2rem;
}

.card {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1rem;
    box-shadow: 0 6px 24px rgba(15, 23, 42, 0.06);
}

.top-controls {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    flex-wrap: wrap;
    margin-bottom: 0.75rem;
}

select, button, input, textarea {
    font: inherit;
}

select, input[type="file"], textarea {
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.5rem 0.75rem;
}

button {
    border: none;
    background: var(--primary);
    color: white;
    padding: 0.5rem 0.9rem;
    border-radius: 8px;
    cursor: pointer;
    transition: transform 120ms ease, box-shadow 120ms ease, opacity 120ms ease;
}

button.secondary {
    background: #e2e8f0;
    color: #0f172a;
}

button:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(37, 99, 235, 0.24); }
button:active { transform: translateY(0); box-shadow: none; }

#chat {
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1rem;
    height: 520px;
    overflow-y: auto;
    background: #f8fafc;
}

.message { margin-bottom: 0.8rem; }
.message .label { display: inline-block; font-weight: 700; margin-bottom: 0.2rem; }
.message.user .label { color: #0ea5e9; }
.message.bot .label { color: #22c55e; }

.input-area {
    margin-top: 0.75rem;
    display: flex;
    gap: 0.5rem;
    align-items: flex-end;
}

#q {
    width: 100%;
    min-height: 80px;
    resize: vertical;
}

.hint { color: var(--text-muted); font-size: 0.9rem; margin-top: 0.25rem; }

.section-title {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 0.5rem;
}

#fileTree ul { list-style: none; padding-left: 1rem; margin: 0.25rem 0; }
#fileTree li { margin: 0.15rem 0; }
#fileTree .folder-name { font-weight: 600; }
#fileTree .actions button { margin-left: 0.35rem; }

.kb-actions { display: flex; flex-direction: column; gap: 0.5rem; }
.inline-group { display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; }
.inline-group input, .inline-group select { flex: 1; }

textarea#systemPrompt { width: 100%; min-height: 160px; resize: vertical; }

.password-controls {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    margin-top: 0.5rem;
}

.password-controls input {
    flex: 1;
}

.details-card summary { cursor: pointer; font-weight: 700; }
.details-card summary::-webkit-details-marker { display: none; }
.details-card summary::before { content: '\25bc'; display: inline-block; margin-right: 0.5rem; transition: transform 120ms ease; }
.details-card[open] summary::before { transform: rotate(0deg); }
.details-card:not([open]) summary::before { transform: rotate(-90deg); }

@media (max-width: 980px) {
    .main { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
    <header>
        <h1>Local RAG Chat</h1>
        <p class="subtitle">Talk to your knowledge bases, manage files and folders, and customize system prompts.</p>
    </header>

    <div class="main">
        <section class="card">
            <div class="top-controls">
                <label for="botSelect"><strong>Active Bot:</strong></label>
                <select id="botSelect"></select>
                <button onclick="createBot()">Create Bot</button>
                <button class="secondary" onclick="deleteBot()">Delete Bot</button>
                <button class="secondary" onclick="clearChat()">Clear Chat</button>
            </div>

            <div id="chat"></div>

            <div class="input-area">
                <textarea id="q" placeholder="Ask something..."></textarea>
                <div style="display:flex;flex-direction:column;gap:0.35rem;">
                    <button onclick="sendMessage()">Send</button>
                    <span class="hint">Press Ctrl + Enter to send</span>
                </div>
            </div>
        </section>

        <section class="card">
            <div class="section-title">
                <strong>Bot Controls</strong>
                <button type="button" class="secondary" onclick="rebuild()">Rebuild Index</button>
            </div>
            <div class="password-controls">
                <input id="passwordInput" type="password" placeholder="Set or change password" />
                <label class="inline-label"><input id="hiddenCheckbox" type="checkbox" /> Hidden</label>
                <button type="button" onclick="updatePassword()">Save Password</button>
                <button type="button" class="secondary" onclick="removePassword()">Remove Password</button>
            </div>
            <span class="hint">You must unlock a private bot before changing or removing its password.</span>

            <details class="details-card" id="kbDetails">
                <summary>Knowledge Base Files</summary>
                <div class="kb-actions">
                    <form id="uploadForm" class="inline-group">
                        <input type="file" name="file" required />
                        <select id="folderSelect"></select>
                        <button type="submit">Upload</button>
                    </form>
                    <span class="hint">ZIP files will be extracted automatically.</span>

                    <div class="inline-group">
                        <input id="newFolderInput" type="text" placeholder="New folder path (e.g. research/notes)" />
                        <button type="button" onclick="createFolder()">Add Folder</button>
                    </div>

                    <div class="inline-group">
                        <select id="deleteFolderSelect"></select>
                        <button type="button" class="secondary" onclick="deleteFolder()">Delete Folder</button>
                    </div>

                    <div class="inline-group">
                        <select id="moveFileSelect"></select>
                        <select id="moveDestSelect"></select>
                        <button type="button" onclick="moveFile()">Move File</button>
                    </div>

                    <div class="section-title">
                        <strong>Files & Folders</strong>
                        <button type="button" class="secondary" onclick="refreshFiles()">Refresh</button>
                    </div>
                    <div id="fileTree"></div>
                </div>
            </details>

            <div style="margin-top:1rem;">
                <div class="section-title">
                    <strong>System Prompt</strong>
                    <div>
                        <button type="button" class="secondary" onclick="loadPrompt()">Reload</button>
                        <button type="button" onclick="savePrompt()">Save</button>
                    </div>
                </div>
                <textarea id="systemPrompt"></textarea>
            </div>
        </section>
    </div>

<script>
const chat = document.getElementById("chat");
const input = document.getElementById("q");
const botSelect = document.getElementById("botSelect");
const folderSelect = document.getElementById("folderSelect");
const deleteFolderSelect = document.getElementById("deleteFolderSelect");
const moveDestSelect = document.getElementById("moveDestSelect");
const moveFileSelect = document.getElementById("moveFileSelect");
const fileTree = document.getElementById("fileTree");
const hiddenCheckbox = document.getElementById("hiddenCheckbox");

const BOT_STORAGE_KEY = "selectedBotId";
const HISTORY_KEY_PREFIX = "chatHistory:";
const PASSWORD_KEY_PREFIX = "botPassword:";
const PASSWORD_HEADER = "X-Bot-Password";

let history = [];
const initialHashBotId = decodeURIComponent(window.location.hash.replace(/^#/, ""));
let currentBotId = initialHashBotId || localStorage.getItem(BOT_STORAGE_KEY);
let botsMeta = [];

input.addEventListener("keydown", e => {
    if (e.key === "Enter" && e.ctrlKey) {
        e.preventDefault();
        sendMessage();
    }
});

botSelect.addEventListener("change", async e => {
    await switchBot(e.target.value, { force: true, requirePasswordPrompt: true });
});

function historyKey(botId) {
    return `${HISTORY_KEY_PREFIX}${botId}`;
}

function passwordKey(botId) {
    return `${PASSWORD_KEY_PREFIX}${botId}`;
}

function getBotPassword(botId) {
    return sessionStorage.getItem(passwordKey(botId)) || "";
}

function setBotPassword(botId, password) {
    if (!botId) return;
    if (password) {
        sessionStorage.setItem(passwordKey(botId), password);
    } else {
        sessionStorage.removeItem(passwordKey(botId));
    }
}

function loadStoredHistory(botId) {
    if (!botId) return [];
    try {
        return JSON.parse(localStorage.getItem(historyKey(botId))) || [];
    } catch (e) {
        return [];
    }
}

function persistHistory() {
    if (!currentBotId) return;
    localStorage.setItem(historyKey(currentBotId), JSON.stringify(history));
}

function buildAuthHeaders() {
    const headers = {};
    const password = getBotPassword(currentBotId);
    if (password) {
        headers[PASSWORD_HEADER] = password;
    }
    return headers;
}

async function authedFetch(url, options = {}, retry = true) {
    const headers = { ...(options.headers || {}), ...buildAuthHeaders() };
    const res = await fetch(url, { ...options, headers });
    if (res.status === 403 && retry && await requestPasswordForCurrentBot()) {
        return authedFetch(url, options, false);
    }
    return res;
}

function findBotMeta(id) {
    return botsMeta.find(b => b.id === id);
}

async function verifyBotPassword(botId, password) {
    const res = await fetch(`/bots/${botId}/access`, {
        method: "POST",
        headers: { "Content-Type": "application/json", ...(password ? { [PASSWORD_HEADER]: password } : {}) },
        body: JSON.stringify({ password })
    });
    return res.ok;
}

async function requestPasswordForBot(botId, { forcePrompt = false } = {}) {
    if (!botId) return false;
    const meta = findBotMeta(botId);
    if (!meta || !meta.protected) {
        setBotPassword(botId, "");
        return true;
    }

    const existing = !forcePrompt ? getBotPassword(botId) : "";
    if (existing && await verifyBotPassword(botId, existing)) {
        return true;
    }

    while (true) {
        const entered = prompt("This bot is private. Enter the password to continue:");
        if (entered === null) {
            return false;
        }
        if (await verifyBotPassword(botId, entered)) {
            setBotPassword(botId, entered);
            return true;
        }
        alert("Incorrect password. Please try again.");
    }
}

function requestPasswordForCurrentBot(options = {}) {
    return requestPasswordForBot(currentBotId, options);
}

function appendUser(msg) {
    const wrapper = document.createElement("div");
    wrapper.className = "message user";
    wrapper.innerHTML = `<div class="label">You</div><div>${msg}</div>`;
    chat.appendChild(wrapper);
    chat.scrollTop = chat.scrollHeight;
}

function appendBotMessage(text) {
    const wrapper = document.createElement("div");
    wrapper.className = "message bot";
    wrapper.innerHTML = `<div class="label">Bot</div><div>${marked.parse(text)}</div>`;
    chat.appendChild(wrapper);
    chat.scrollTop = chat.scrollHeight;
}

function appendTyping() {
    const el = document.createElement("div");
    el.className = "message bot";
    el.innerHTML = "<div class=\"label\">Bot</div><i>Bot is typingâ€¦</i>";
    chat.appendChild(el);
    chat.scrollTop = chat.scrollHeight;
    return el;
}

function appendBotContainer() {
    const el = document.createElement("div");
    el.className = "message bot";
    el.innerHTML = "<div class=\"label\">Bot</div><div></div>";
    el.rawText = "";
    el.tokenCount = 0;
    chat.appendChild(el);
    chat.scrollTop = chat.scrollHeight;
    return el;
}

function renderHistoryMessages() {
    chat.innerHTML = "";
    history.forEach(entry => {
        if (entry.role === "user") {
            appendUser(entry.content.replaceAll("\n", "<br>"));
        } else if (entry.role === "assistant") {
            appendBotMessage(entry.content);
        }
    });
}

function ensureBotSelected() {
    if (!currentBotId) {
        alert("Please create or select a bot first.");
        return false;
    }
    return true;
}

function clearChat() {
    history = [];
    chat.innerHTML = "";
    if (currentBotId) {
        localStorage.removeItem(historyKey(currentBotId));
    }
}

async function sendMessage() {
    if (!ensureBotSelected()) return;

    const q = input.value.trim();
    if (!q) return;

    history.push({ role: "user", content: q });
    persistHistory();

    appendUser(q.replaceAll("\n", "<br>"));
    input.value = "";

    const typingEl = appendTyping();

    const response = await authedFetch("/ask_stream", {
        method: "POST",
        headers: {"Content-Type": "application/json", ...buildAuthHeaders()},
        body: JSON.stringify({ q, bot_id: currentBotId, password: getBotPassword(currentBotId) })
    });

    if (!response.ok || !response.body) {
        if (typingEl.parentNode) typingEl.remove();
        const text = await response.text();
        const errorEl = document.createElement("div");
        errorEl.className = "message bot";
        const message = text || response.statusText || "Error communicating with the bot.";
        errorEl.innerHTML = `<div class="label">Bot</div><i>${message}</i>`;
        chat.appendChild(errorEl);
        chat.scrollTop = chat.scrollHeight;
        return;
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buf = "";

    const botContainer = appendBotContainer();

    while (true) {
        const { value, done } = await reader.read();
        if (done) break;

        buf += decoder.decode(value, {stream:true});
        const lines = buf.split("\n");
        buf = lines.pop();

        for (let ln of lines) {
            if (!ln.trim()) continue;

            const event = JSON.parse(ln);

            if (typingEl.parentNode) typingEl.remove();

            if (event.type === "token") {
                botContainer.rawText += event.token;
                botContainer.tokenCount++;

                if (botContainer.tokenCount % 5 === 0) {
                    botContainer.children[1].innerHTML = marked.parse(botContainer.rawText);
                    chat.scrollTop = chat.scrollHeight;
                }
            }
        }
    }

    botContainer.children[1].innerHTML = marked.parse(botContainer.rawText);
    chat.scrollTop = chat.scrollHeight;

    history.push({ role: "assistant", content: botContainer.rawText });
    persistHistory();
}

document.getElementById("uploadForm").onsubmit = async e => {
    e.preventDefault();
    if (!ensureBotSelected()) return;
    const form = new FormData(e.target);
    form.append("path", folderSelect.value || "");
    await authedFetch(`/bots/${currentBotId}/upload`, { method: "POST", headers: buildAuthHeaders(), body: form });
    alert("Uploaded");
    refreshFiles();
};

async function rebuild() {
    if (!ensureBotSelected()) return;
    await authedFetch(`/bots/${currentBotId}/rebuild`, { method: "POST", headers: buildAuthHeaders() });
    alert("Reindexed!");
}

function collectFolders(node, list = []) {
    if (node.path !== undefined) {
        list.push(node.path || "");
    }
    (node.folders || []).forEach(f => collectFolders(f, list));
    return list;
}

function collectFiles(node, list = []) {
    (node.files || []).forEach(f => list.push(f.path));
    (node.folders || []).forEach(f => collectFiles(f, list));
    return list;
}

function renderTree(node, container) {
    container.innerHTML = "";
    const list = document.createElement("ul");

    const renderNode = (n) => {
        const li = document.createElement("li");
        if (n.type === "folder") {
            const title = document.createElement("div");
            title.className = "folder-name";
            title.textContent = n.path ? n.name : "Root";
            if (n.path) {
                const delBtn = document.createElement("button");
                delBtn.className = "secondary";
                delBtn.textContent = "Delete";
                delBtn.onclick = () => deleteFolder(n.path);
                title.appendChild(delBtn);
            }
            li.appendChild(title);
            if ((n.folders && n.folders.length) || (n.files && n.files.length)) {
                const inner = document.createElement("ul");
                (n.folders || []).forEach(child => inner.appendChild(renderNode(child)));
                (n.files || []).forEach(file => {
                    const fileLi = document.createElement("li");
                    const nameSpan = document.createElement("span");
                    nameSpan.textContent = file.name;
                    const delBtn = document.createElement("button");
                    delBtn.className = "secondary";
                    delBtn.textContent = "Delete";
                    delBtn.onclick = () => deleteFileKB(file.path);
                    fileLi.appendChild(nameSpan);
                    fileLi.appendChild(delBtn);
                    inner.appendChild(fileLi);
                });
                li.appendChild(inner);
            }
        }
        return li;
    };

    list.appendChild(renderNode(node));
    container.appendChild(list);
}

async function refreshFiles() {
    if (!currentBotId) {
        fileTree.innerHTML = "";
        folderSelect.innerHTML = "";
        deleteFolderSelect.innerHTML = "";
        moveDestSelect.innerHTML = "";
        moveFileSelect.innerHTML = "";
        return;
    }

    const r = await authedFetch(`/bots/${currentBotId}/files`);
    const data = await r.json();
    const tree = data.tree;
    renderTree(tree, fileTree);

    const folders = collectFolders(tree, []);

    folderSelect.innerHTML = "";
    folders.forEach(path => {
        const option = document.createElement("option");
        option.value = path;
        option.textContent = path ? path : "Root (/ )";
        folderSelect.appendChild(option);
    });

    deleteFolderSelect.innerHTML = "";
    folders.filter(f => f).forEach(path => {
        const option = document.createElement("option");
        option.value = path;
        option.textContent = path;
        deleteFolderSelect.appendChild(option);
    });

    moveDestSelect.innerHTML = "";
    folders.forEach(path => {
        const option = document.createElement("option");
        option.value = path;
        option.textContent = path ? path : "Root (/ )";
        moveDestSelect.appendChild(option);
    });

    const files = collectFiles(tree, []);
    moveFileSelect.innerHTML = "";
    files.forEach(path => {
        const option = document.createElement("option");
        option.value = path;
        option.textContent = path;
        moveFileSelect.appendChild(option);
    });
}

async function deleteFileKB(name) {
    if (!ensureBotSelected()) return;
    await authedFetch(`/bots/${currentBotId}/file/${encodeURIComponent(name)}`, { method: "DELETE", headers: buildAuthHeaders() });
    alert("Deleted " + name);
    refreshFiles();
}

async function createFolder() {
    if (!ensureBotSelected()) return;
    const inputEl = document.getElementById("newFolderInput");
    const path = (inputEl.value || "").trim();
    if (!path) {
        alert("Please enter a folder path.");
        return;
    }
    await authedFetch(`/bots/${currentBotId}/folders`, {
        method: "POST",
        headers: {"Content-Type": "application/json", ...buildAuthHeaders()},
        body: JSON.stringify({ path })
    });
    inputEl.value = "";
    refreshFiles();
}

async function deleteFolder(path) {
    if (!ensureBotSelected()) return;
    const folderPath = typeof path === "string" ? path : deleteFolderSelect.value;
    if (!folderPath) {
        alert("Select a folder to delete.");
        return;
    }
    await authedFetch(`/bots/${currentBotId}/folders?path=${encodeURIComponent(folderPath)}`, { method: "DELETE", headers: buildAuthHeaders() });
    refreshFiles();
}

async function moveFile() {
    if (!ensureBotSelected()) return;
    const source = moveFileSelect.value;
    const destination_folder = moveDestSelect.value;
    if (!source) {
        alert("Select a file to move.");
        return;
    }
    await authedFetch(`/bots/${currentBotId}/move_file`, {
        method: "POST",
        headers: {"Content-Type": "application/json", ...buildAuthHeaders()},
        body: JSON.stringify({ source, destination_folder })
    });
    refreshFiles();
}

async function loadPrompt() {
    if (!currentBotId) {
        document.getElementById("systemPrompt").value = "";
        return;
    }
    const r = await authedFetch(`/bots/${currentBotId}/prompt`);
    const data = await r.json();
    document.getElementById("systemPrompt").value = data.prompt;
}

async function savePrompt() {
    if (!ensureBotSelected()) return;
    const txt = document.getElementById("systemPrompt").value;
    await authedFetch(`/bots/${currentBotId}/prompt`, {
        method: "POST",
        headers: {"Content-Type": "application/json", ...buildAuthHeaders()},
        body: JSON.stringify({ prompt: txt })
    });
    alert("Saved");
}

async function updatePassword() {
    if (!ensureBotSelected()) return;
    const hasAccess = await requestPasswordForCurrentBot();
    if (!hasAccess) return;

    const newPassword = (document.getElementById("passwordInput").value || "").trim();
    const hidden = hiddenCheckbox.checked;
    const res = await authedFetch(`/bots/${currentBotId}/password`, {
        method: "POST",
        headers: {"Content-Type": "application/json", ...buildAuthHeaders()},
        body: JSON.stringify({ new_password: newPassword, hidden })
    });

    if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        alert(err.detail || "Unable to update password.");
        return;
    }

    const data = await res.json();
    setBotPassword(currentBotId, newPassword);
    const meta = findBotMeta(currentBotId);
    if (meta) {
        meta.protected = !!data?.protected;
        meta.hidden = !!data?.hidden;
    }
    alert(newPassword ? "Password updated." : "Password removed.");
    document.getElementById("passwordInput").value = "";
}

async function removePassword() {
    document.getElementById("passwordInput").value = "";
    await updatePassword();
}

async function loadBots() {
    const hashBotId = decodeURIComponent(window.location.hash.replace(/^#/, ""));
    const r = await fetch("/bots");
    const data = await r.json();
    botsMeta = data.bots || [];

    botSelect.innerHTML = "";

    const visibleBots = botsMeta.filter(bot => !bot.hidden);
    visibleBots.forEach(bot => {
        const option = document.createElement("option");
        option.value = bot.id;
        option.textContent = bot.protected ? `${bot.name} *` : bot.name;
        botSelect.appendChild(option);
    });

    botSelect.disabled = visibleBots.length === 0;

    if (!data.bots.length) {
        await switchBot(null);
        return;
    }

    const preferredBotId = hashBotId || currentBotId;
    if (preferredBotId && data.bots.some(bot => bot.id === preferredBotId)) {
        currentBotId = preferredBotId;
    } else if (!currentBotId || !data.bots.some(bot => bot.id === currentBotId)) {
        currentBotId = visibleBots[0]?.id || null;
    }

    botSelect.value = currentBotId;
    await switchBot(currentBotId, { force: true, requirePasswordPrompt: true });
}

async function switchBot(id, { force = false, requirePasswordPrompt = false } = {}) {
    const promptBox = document.getElementById("systemPrompt");

    if (!id) {
        currentBotId = null;
        localStorage.removeItem(BOT_STORAGE_KEY);
        history = [];
        chat.innerHTML = "<div class=\"message bot\"><div class=\"label\">Bot</div><i>No bots available. Create one to begin.</i></div>";
        promptBox.value = "";
        fileTree.innerHTML = "";
        hiddenCheckbox.checked = false;
        if (window.location.hash) {
            history.replaceState(null, "", window.location.pathname);
        }
        return;
    }

    if (!force && id === currentBotId) {
        await Promise.all([loadPrompt(), refreshFiles()]);
        renderHistoryMessages();
        return;
    }

    const previousBot = currentBotId;
    currentBotId = id;

    const meta = findBotMeta(id);
    if (meta && meta.protected) {
        const unlocked = await requestPasswordForBot(id, { forcePrompt: requirePasswordPrompt });
        if (!unlocked) {
            currentBotId = previousBot;
            if (botSelect.value !== previousBot) {
                botSelect.value = previousBot || "";
            }
            return;
        }
    } else {
        setBotPassword(id, "");
    }

    localStorage.setItem(BOT_STORAGE_KEY, currentBotId);
    hiddenCheckbox.checked = !!meta?.hidden;
    if (botSelect.value !== id) {
        botSelect.value = id;
    }

    history = loadStoredHistory(currentBotId);
    renderHistoryMessages();
    document.getElementById("passwordInput").value = "";
    await Promise.all([loadPrompt(), refreshFiles()]);
    if (currentBotId) {
        const targetHash = `#${encodeURIComponent(currentBotId)}`;
        if (window.location.hash !== targetHash) {
            window.location.hash = targetHash;
        }
    }
}

async function createBot() {
    const name = prompt("Name for the new bot:");
    if (!name || !name.trim()) return;

    const promptText = prompt("Optional system prompt (leave blank for default):", "");
    const passwordText = prompt("Optional password (leave blank for a public bot):", "");
    const payload = { name: name.trim() };
    if (promptText !== null && promptText.trim() !== "") {
        payload.prompt = promptText;
    }
    if (passwordText !== null && passwordText.trim() !== "") {
        payload.password = passwordText.trim();
    }
    payload.hidden = hiddenCheckbox.checked;

    const res = await fetch("/bots", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload)
    });

    if (!res.ok) {
        let detail = res.statusText;
        try {
            const err = await res.json();
            detail = err.detail || detail;
        } catch (e) {}
        alert("Failed to create bot: " + detail);
        return;
    }

    const data = await res.json();
    currentBotId = data.bot.id;
    localStorage.setItem(BOT_STORAGE_KEY, currentBotId);
    await loadBots();
    alert(`Created bot "${data.bot.name}"`);
}

async function deleteBot() {
    if (!ensureBotSelected()) return;

    const meta = findBotMeta(currentBotId);
    const label = meta ? meta.name : currentBotId;
    if (!confirm(`Delete bot "${label}"? This cannot be undone.`)) return;

    const hasAccess = await requestPasswordForBot(currentBotId, { forcePrompt: true });
    if (!hasAccess) return;

    const res = await authedFetch(`/bots/${currentBotId}`, {
        method: "DELETE",
        headers: { "Content-Type": "application/json", ...buildAuthHeaders() },
        body: JSON.stringify({ password: getBotPassword(currentBotId) })
    });

    if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        alert(err.detail || "Failed to delete bot.");
        return;
    }

    setBotPassword(currentBotId, "");
    alert("Bot deleted.");
    currentBotId = null;
    await loadBots();
}

loadBots();
</script>
</body>
</html>

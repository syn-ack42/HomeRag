<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Local RAG Chat</title>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<style>
:root {
    --bg: #f5f7fb;
    --panel: #ffffff;
    --border: #dce2ec;
    --primary: #2563eb;
    --text-muted: #5f6b7a;
}

* { box-sizing: border-box; }
body {
    font-family: "Inter", system-ui, -apple-system, sans-serif;
    margin: 0;
    padding: 0;
    background: var(--bg);
    color: #0f172a;
}

header {
    padding: 1.5rem 2rem 0.5rem;
}

h1 {
    margin: 0 0 0.25rem;
    font-size: 1.8rem;
}

.subtitle {
    color: var(--text-muted);
    margin: 0;
}

.main {
    display: grid;
    grid-template-columns: minmax(0, 70%) minmax(320px, 30%);
    gap: 1rem;
    padding: 0 2rem 2rem;
}

.card {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1rem;
    box-shadow: 0 6px 24px rgba(15, 23, 42, 0.06);
}

.top-controls {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    flex-wrap: wrap;
    margin-bottom: 0.75rem;
}

select, button, input, textarea {
    font: inherit;
}

select, input[type="file"], textarea {
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.5rem 0.75rem;
}

button {
    border: none;
    background: var(--primary);
    color: white;
    padding: 0.5rem 0.9rem;
    border-radius: 8px;
    cursor: pointer;
    transition: transform 120ms ease, box-shadow 120ms ease, opacity 120ms ease;
}

button.secondary {
    background: #e2e8f0;
    color: #0f172a;
}

button:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(37, 99, 235, 0.24); }
button:active { transform: translateY(0); box-shadow: none; }

#chat {
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1rem;
    height: 520px;
    overflow-y: auto;
    background: #f8fafc;
}

.message { margin-bottom: 0.8rem; }
.message .label { display: inline-block; font-weight: 700; margin-bottom: 0.2rem; }
.message.user .label { color: #0ea5e9; }
.message.bot .label { color: #22c55e; }
.message .bot-meta {
    color: var(--text-muted);
    font-size: 0.85rem;
    margin-top: 0.35rem;
    border-left: 2px solid var(--border);
    padding-left: 0.5rem;
    line-height: 1.3;
}

.input-area {
    margin-top: 0.75rem;
    display: flex;
    gap: 0.5rem;
    align-items: flex-end;
}

#q {
    width: 100%;
    min-height: 80px;
    resize: vertical;
}

.hint { color: var(--text-muted); font-size: 0.9rem; margin-top: 0.25rem; }

.section-title {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 0.5rem;
}

#fileTree ul { list-style: none; padding-left: 1rem; margin: 0.25rem 0; }
#fileTree li { margin: 0.15rem 0; }
#fileTree .folder-name { font-weight: 600; }
#fileTree .actions button { margin-left: 0.35rem; }

.kb-actions { display: flex; flex-direction: column; gap: 0.5rem; }
.inline-group { display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; }
.inline-group input, .inline-group select { flex: 1; }

textarea#systemPrompt { width: 100%; min-height: 160px; resize: vertical; }

.password-controls {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    margin-top: 0.5rem;
}

.password-controls input {
    flex: 1;
}

.details-card summary { cursor: pointer; font-weight: 700; }
.details-card summary::-webkit-details-marker { display: none; }
.details-card summary::before { content: '\25bc'; display: inline-block; margin-right: 0.5rem; transition: transform 120ms ease; }
.details-card[open] summary::before { transform: rotate(0deg); }
.details-card:not([open]) summary::before { transform: rotate(-90deg); }

.modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(15, 23, 42, 0.45);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.modal-card {
    background: #fff;
    border-radius: 12px;
    padding: 1rem;
    width: min(420px, 92vw);
    box-shadow: 0 18px 40px rgba(15, 23, 42, 0.35);
}

.modal-card h3 {
    margin: 0 0 0.25rem;
}

.modal-card p {
    margin: 0 0 0.75rem;
    color: var(--text-muted);
}

.modal-card input[type="password"] {
    width: 100%;
    margin-bottom: 0.75rem;
}

.modal-card .actions {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
}

.modal-error {
    color: #dc2626;
    font-size: 0.9rem;
    margin-bottom: 0.5rem;
}

.settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 0.75rem;
    margin: 0.5rem 0 1rem;
}

.settings-grid label {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    font-weight: 600;
}

.settings-grid small {
    font-weight: 400;
    color: var(--text-muted);
}

.model-info {
    margin-top: 0.35rem;
    padding: 0.55rem 0.65rem;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: #f8fafc;
    color: #0f172a;
    font-size: 0.95rem;
}

.model-info .title {
    font-weight: 700;
    margin-bottom: 0.35rem;
}

.model-info ul {
    margin: 0.15rem 0 0;
    padding-left: 1.1rem;
    color: var(--text-muted);
}

.model-status {
    display: flex;
    align-items: center;
    gap: 0.35rem;
    flex-wrap: wrap;
    margin-top: 0.35rem;
}

.status-pill {
    display: inline-block;
    padding: 0.1rem 0.5rem;
    border-radius: 999px;
    background: #e2e8f0;
    color: #0f172a;
    font-weight: 600;
    font-size: 0.85rem;
}

@media (max-width: 980px) {
    .main { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
    <header>
        <h1>Local RAG Chat</h1>
        <p class="subtitle">Talk to your knowledge bases, manage files and folders, and customize system prompts.</p>
    </header>

    <div class="main">
        <section class="card">
            <div class="top-controls">
                <label for="botSelect"><strong>Active Bot:</strong></label>
                <select id="botSelect"></select>
                <button onclick="createBot()">Create Bot</button>
                <button class="secondary" onclick="deleteBot()">Delete Bot</button>
                <button class="secondary" onclick="clearChat()">Clear Chat</button>
            </div>

            <div id="chat"></div>

            <div class="input-area">
                <textarea id="q" placeholder="Ask something..."></textarea>
                <div style="display:flex;flex-direction:column;gap:0.35rem;">
                    <button onclick="sendMessage()">Send</button>
                    <span class="hint">Press Ctrl + Enter to send</span>
                </div>
            </div>
        </section>

        <section class="card">
            <div class="section-title">
                <strong>Bot Controls</strong>
            </div>
            <div class="password-controls">
                <input id="passwordInput" type="password" placeholder="Set or change password" />
                <label class="inline-label"><input id="hiddenCheckbox" type="checkbox" /> Hidden</label>
                <button type="button" onclick="updatePassword()">Save Password</button>
            </div>
            <span class="hint">You must unlock a private bot before changing or removing its password.</span>

            <div style="margin-top:1rem;">
                <div class="section-title">
                    <strong>System Prompt</strong>
                    <div>
                        <button type="button" class="secondary" onclick="loadPrompt()">Reload</button>
                        <button type="button" onclick="savePrompt()">Save</button>
                    </div>
                </div>
                <textarea id="systemPrompt"></textarea>
            </div>

            <div style="margin-top:1rem;">
                <div class="section-title">
                    <strong>Retrieval &amp; Model Settings</strong>
                    <div>
                        <button type="button" class="secondary" onclick="loadConfig()">Reload</button>
                        <button type="button" onclick="saveConfig()">Save Settings</button>
                    </div>
                </div>
                <div class="settings-grid">
                    <label>Embedding Model
                        <select id="embeddingModel"></select>
                        <div id="embeddingModelInfo" class="model-info" style="display:none;"></div>
                        <div class="model-status" id="embeddingStatusRow" style="display:none;">
                            <span class="status-pill" id="embeddingStatus"></span>
                            <button type="button" class="secondary" id="rebuildEmbeddingButton" onclick="rebuildSelectedEmbedding()">Rebuild Selected Index</button>
                        </div>
                    </label>
                    <label>LLM Model
                        <select id="llmModel"></select>
                        <div id="llmModelInfo" class="model-info" style="display:none;"></div>
                    </label>
                    <label>Chunk Size
                        <input id="chunkSize" type="number" min="1" />
                    </label>
                    <label>Chunk Overlap
                        <input id="chunkOverlap" type="number" min="0" />
                    </label>
                    <label>Retrieval Top K
                        <input id="retrievalTopK" type="number" min="1" />
                    </label>
                    <label>History Enabled
                        <div class="inline-group" style="justify-content: space-between;">
                            <label class="inline-label"><input id="historyEnabled" type="checkbox" /> Enable</label>
                            <input id="historyTurns" type="number" min="0" placeholder="Turns to keep" />
                        </div>
                        <small>Set turns to 0 to disable history truncation.</small>
                    </label>
                    <label>LLM Temperature
                        <input id="llmTemperature" type="number" step="0.01" />
                    </label>
                    <label>LLM Top P
                        <input id="llmTopP" type="number" step="0.01" />
                    </label>
                    <label>Max Output Tokens
                        <input id="llmMaxTokens" type="number" min="0" />
                        <small>0 uses the model default.</small>
                    </label>
                    <label>Repeat Penalty
                        <input id="llmRepeatPenalty" type="number" step="0.01" />
                    </label>
                </div>
            </div>

            <div class="section-title">
                <strong>Index</strong>
                <button type="button" class="secondary" onclick="rebuild()">Rebuild Index</button>
            </div>

            <details class="details-card" id="kbDetails">
                <summary>Knowledge Base Files</summary>
                <div class="kb-actions">
                    <form id="uploadForm" class="inline-group">
                        <input type="file" name="file" required />
                        <select id="folderSelect"></select>
                        <button type="submit">Upload</button>
                    </form>
                    <span class="hint">ZIP files will be extracted automatically.</span>

                    <div class="inline-group">
                        <input id="newFolderInput" type="text" placeholder="New folder path (e.g. research/notes)" />
                        <button type="button" onclick="createFolder()">Add Folder</button>
                    </div>

                    <div class="inline-group">
                        <select id="deleteFolderSelect"></select>
                        <button type="button" class="secondary" onclick="deleteFolder()">Delete Folder</button>
                    </div>

                    <div class="inline-group">
                        <select id="moveFileSelect"></select>
                        <select id="moveDestSelect"></select>
                        <button type="button" onclick="moveFile()">Move File</button>
                    </div>

                    <div class="section-title">
                        <strong>Files & Folders</strong>
                        <button type="button" class="secondary" onclick="refreshFiles()">Refresh</button>
                    </div>
                    <div id="fileTree"></div>
                </div>
            </details>
        </section>
    </div>

<script>
const chat = document.getElementById("chat");
const input = document.getElementById("q");
const botSelect = document.getElementById("botSelect");
const folderSelect = document.getElementById("folderSelect");
const deleteFolderSelect = document.getElementById("deleteFolderSelect");
const moveDestSelect = document.getElementById("moveDestSelect");
const moveFileSelect = document.getElementById("moveFileSelect");
const fileTree = document.getElementById("fileTree");
const hiddenCheckbox = document.getElementById("hiddenCheckbox");
const passwordInput = document.getElementById("passwordInput");
const embeddingModelSelect = document.getElementById("embeddingModel");
const llmModelSelect = document.getElementById("llmModel");
const chunkSizeInput = document.getElementById("chunkSize");
const chunkOverlapInput = document.getElementById("chunkOverlap");
const retrievalTopKInput = document.getElementById("retrievalTopK");
const historyEnabledInput = document.getElementById("historyEnabled");
const historyTurnsInput = document.getElementById("historyTurns");
const llmTemperatureInput = document.getElementById("llmTemperature");
const llmTopPInput = document.getElementById("llmTopP");
const llmMaxTokensInput = document.getElementById("llmMaxTokens");
const llmRepeatPenaltyInput = document.getElementById("llmRepeatPenalty");
const embeddingModelInfo = document.getElementById("embeddingModelInfo");
const embeddingStatusRow = document.getElementById("embeddingStatusRow");
const embeddingStatusText = document.getElementById("embeddingStatus");
const rebuildEmbeddingButton = document.getElementById("rebuildEmbeddingButton");
const llmModelInfo = document.getElementById("llmModelInfo");

const BOT_STORAGE_KEY = "selectedBotId";
const PASSWORD_KEY_PREFIX = "botPassword:";
const PASSWORD_HEADER = "X-Bot-Password";
const DEFAULT_LLM_MODEL = "phi3";

const DEFAULT_CONFIG = {
    embedding_model: "mxbai-embed-large",
    llm_model: DEFAULT_LLM_MODEL,
    chunk_size: 800,
    chunk_overlap: 100,
    retrieval_top_k: 3,
    history_enabled: true,
    history_turns: 10,
    llm_temperature: 0,
    llm_top_p: 0.9,
    llm_max_output_tokens: 512,
    llm_repeat_penalty: 1.1,
};

const botConversations = {};
let messages = [];
const initialHashBotId = decodeURIComponent(window.location.hash.replace(/^#/, ""));
let currentBotId = initialHashBotId || localStorage.getItem(BOT_STORAGE_KEY);
let botsMeta = [];
let passwordEdited = false;
let availableEmbeddingModels = [];
let embeddingModelsError = "";
let availableLLMModels = [];
let llmModelsError = "";
let embeddingStatuses = {};

function normalizeModelEntries(models = []) {
    return (models || [])
        .map(entry => {
            if (typeof entry === "string") {
                return { name: entry, details: {} };
            }
            const name = entry?.name || entry?.model || "";
            return { name, details: entry?.details || {} };
        })
        .filter(entry => entry.name);
}

function findModelEntry(list, name) {
    return list.find(item => item.name === name);
}

function appendErrorMessage(message) {
    const el = document.createElement("div");
    el.className = "message bot";

    const label = document.createElement("div");
    label.className = "label";
    label.textContent = "Bot";

    const content = document.createElement("div");
    content.className = "bot-content";
    const italic = document.createElement("i");
    italic.textContent = message;
    content.appendChild(italic);

    el.appendChild(label);
    el.appendChild(content);

    chat.appendChild(el);
    chat.scrollTop = chat.scrollHeight;
}

async function buildErrorMessageFromResponse(response) {
    const statusPart = response?.status ? ` (${response.status})` : "";
    let body = "";

    try {
        body = await response.text();
    } catch (_) {
        body = "";
    }

    let detail = "";
    if (body) {
        try {
            const parsed = JSON.parse(body);
            detail = parsed?.detail || body;
        } catch (_) {
            detail = body;
        }
    }

    detail = detail || response.statusText || "Unexpected error";
    return `Backend error${statusPart}: ${detail}`;
}

input.addEventListener("keydown", e => {
    if (e.key === "Enter" && e.ctrlKey) {
        e.preventDefault();
        sendMessage();
    }
});

botSelect.addEventListener("change", async e => {
    await switchBot(e.target.value, { force: true, requirePasswordPrompt: true });
});

passwordInput.addEventListener("input", () => {
    if (passwordInput.dataset.masked === "true" && passwordInput.value === "••••") {
        passwordEdited = false;
        return;
    }
    passwordInput.dataset.masked = "false";
    passwordEdited = true;
});

embeddingModelSelect.addEventListener("change", () => {
    renderEmbeddingInfoBox();
});

llmModelSelect.addEventListener("change", async () => {
    if (!currentBotId || llmModelSelect.disabled || llmModelsError) return;
    const selected = llmModelSelect.value;
    const res = await authedFetch(`/bots/${currentBotId}/model`, {
        method: "POST",
        headers: { "Content-Type": "application/json", ...buildAuthHeaders() },
        body: JSON.stringify({ model: selected })
    });

    if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        alert(err.detail || "Unable to update model.");
        await loadBotModel();
    }
    renderLLMInfoBox();
});

function renderEmbeddingOptions(selectedValue = DEFAULT_CONFIG.embedding_model) {
    embeddingModelSelect.innerHTML = "";

    if (embeddingModelsError) {
        const option = document.createElement("option");
        option.textContent = embeddingModelsError;
        option.disabled = true;
        option.value = "";
        embeddingModelSelect.appendChild(option);
        embeddingModelSelect.disabled = true;
        renderEmbeddingInfoBox();
        return;
    }

    if (!availableEmbeddingModels.length) {
        const option = document.createElement("option");
        option.textContent = "No embedding models available";
        option.disabled = true;
        option.value = "";
        embeddingModelSelect.appendChild(option);
        embeddingModelSelect.disabled = true;
        renderEmbeddingInfoBox();
        return;
    }

    availableEmbeddingModels.forEach(model => {
        const option = document.createElement("option");
        option.value = model.name;
        option.textContent = model.name;
        embeddingModelSelect.appendChild(option);
    });

    const modelNames = availableEmbeddingModels.map(m => m.name);
    const valueToUse = modelNames.includes(selectedValue) ? selectedValue : modelNames[0];
    embeddingModelSelect.value = valueToUse || "";
    embeddingModelSelect.disabled = false;
    renderEmbeddingInfoBox();
}

async function loadAvailableEmbeddingModels() {
    if (loadAvailableEmbeddingModels.loading) return loadAvailableEmbeddingModels.loading;
    embeddingModelSelect.innerHTML = "<option>Loading embedding models...</option>";
    embeddingModelSelect.disabled = true;
    loadAvailableEmbeddingModels.loading = (async () => {
        try {
            const res = await fetch("/embedding-models");
            if (!res.ok) throw new Error("Failed to load embedding models");
            const data = await res.json();
            availableEmbeddingModels = normalizeModelEntries(data.models);
            embeddingModelsError = availableEmbeddingModels.length ? "" : "No embedding models available";
        } catch (e) {
            availableEmbeddingModels = [];
            embeddingModelsError = "Unable to load embedding models";
        }
        renderEmbeddingOptions(embeddingModelSelect.value || DEFAULT_CONFIG.embedding_model);
        loadAvailableEmbeddingModels.loading = null;
    })();
    return loadAvailableEmbeddingModels.loading;
}

function renderModelOptions(selectedValue = DEFAULT_LLM_MODEL) {
    llmModelSelect.innerHTML = "";

    if (llmModelsError) {
        const option = document.createElement("option");
        option.textContent = llmModelsError;
        option.disabled = true;
        option.value = "";
        llmModelSelect.appendChild(option);
        llmModelSelect.disabled = true;
        renderLLMInfoBox();
        return;
    }

    if (!availableLLMModels.length) {
        const option = document.createElement("option");
        option.textContent = "No models available";
        option.disabled = true;
        option.value = "";
        llmModelSelect.appendChild(option);
        llmModelSelect.disabled = true;
        renderLLMInfoBox();
        return;
    }

    availableLLMModels.forEach(model => {
        const option = document.createElement("option");
        option.value = model.name;
        option.textContent = model.name;
        llmModelSelect.appendChild(option);
    });

    const modelNames = availableLLMModels.map(m => m.name);
    const valueToUse = modelNames.includes(selectedValue) ? selectedValue : modelNames[0];
    llmModelSelect.value = valueToUse || "";
    llmModelSelect.disabled = !currentBotId;
    renderLLMInfoBox();
}

async function loadAvailableLLMModels() {
    if (loadAvailableLLMModels.loading) return loadAvailableLLMModels.loading;
    llmModelSelect.innerHTML = "<option>Loading models...</option>";
    llmModelSelect.disabled = true;
    loadAvailableLLMModels.loading = (async () => {
        try {
            const res = await fetch("/models");
            if (!res.ok) throw new Error("Failed to load models");
            const data = await res.json();
            availableLLMModels = normalizeModelEntries(data.models);
            llmModelsError = availableLLMModels.length ? "" : "No models available";
        } catch (e) {
            availableLLMModels = [];
            llmModelsError = "Unable to load models";
        }
        renderModelOptions(llmModelSelect.value || DEFAULT_LLM_MODEL);
        loadAvailableLLMModels.loading = null;
    })();
    return loadAvailableLLMModels.loading;
}

async function loadBotModel() {
    if (!currentBotId) {
        renderModelOptions(DEFAULT_LLM_MODEL);
        llmModelSelect.disabled = true;
        return;
    }

    await loadAvailableLLMModels();
    if (llmModelsError) return;

    const res = await authedFetch(`/bots/${currentBotId}/model`);
    if (!res.ok) {
        renderModelOptions(DEFAULT_LLM_MODEL);
        return;
    }
    const data = await res.json();
    renderModelOptions(data.model || DEFAULT_LLM_MODEL);
}

function passwordKey(botId) {
    return `${PASSWORD_KEY_PREFIX}${botId}`;
}

function getBotPassword(botId) {
    return sessionStorage.getItem(passwordKey(botId)) || "";
}

function setBotPassword(botId, password) {
    if (!botId) return;
    if (password) {
        sessionStorage.setItem(passwordKey(botId), password);
    } else {
        sessionStorage.removeItem(passwordKey(botId));
    }
}

function buildAuthHeaders() {
    const headers = {};
    const password = getBotPassword(currentBotId);
    if (password) {
        headers[PASSWORD_HEADER] = password;
    }
    return headers;
}

async function authedFetch(url, options = {}, retry = true) {
    const headers = { ...(options.headers || {}), ...buildAuthHeaders() };
    const res = await fetch(url, { ...options, headers });
    if (res.status === 403 && retry && await requestPasswordForCurrentBot()) {
        return authedFetch(url, options, false);
    }
    return res;
}

function parseIntInput(el) {
    const v = parseInt(el.value, 10);
    return Number.isFinite(v) ? v : null;
}

function parseFloatInput(el) {
    const v = parseFloat(el.value);
    return Number.isFinite(v) ? v : null;
}

function applyConfigToForm(config = DEFAULT_CONFIG) {
    const cfg = { ...DEFAULT_CONFIG, ...(config || {}) };
    renderEmbeddingOptions(cfg.embedding_model || DEFAULT_CONFIG.embedding_model);
    renderModelOptions(cfg.llm_model || DEFAULT_CONFIG.llm_model);
    chunkSizeInput.value = cfg.chunk_size ?? DEFAULT_CONFIG.chunk_size;
    chunkOverlapInput.value = cfg.chunk_overlap ?? DEFAULT_CONFIG.chunk_overlap;
    retrievalTopKInput.value = cfg.retrieval_top_k ?? DEFAULT_CONFIG.retrieval_top_k;
    historyEnabledInput.checked = !!cfg.history_enabled;
    historyTurnsInput.value = cfg.history_turns ?? DEFAULT_CONFIG.history_turns;
    llmTemperatureInput.value = cfg.llm_temperature ?? DEFAULT_CONFIG.llm_temperature;
    llmTopPInput.value = cfg.llm_top_p ?? DEFAULT_CONFIG.llm_top_p;
    llmMaxTokensInput.value = cfg.llm_max_output_tokens ?? DEFAULT_CONFIG.llm_max_output_tokens;
    llmRepeatPenaltyInput.value = cfg.llm_repeat_penalty ?? DEFAULT_CONFIG.llm_repeat_penalty;
}

async function loadEmbeddingStatuses() {
    if (!currentBotId) {
        embeddingStatuses = {};
        renderEmbeddingInfoBox();
        return;
    }

    const modelQuery = embeddingModelSelect.value
        ? `?models=${encodeURIComponent(embeddingModelSelect.value)}`
        : "";
    const res = await authedFetch(`/bots/${currentBotId}/embedding-status${modelQuery}`);
    if (res.ok) {
        const data = await res.json().catch(() => ({}));
        embeddingStatuses = data.statuses || {};
    } else {
        embeddingStatuses = {};
    }
    renderEmbeddingInfoBox();
}

async function loadConfig() {
    await loadAvailableEmbeddingModels();
    if (!currentBotId) {
        applyConfigToForm();
        await loadEmbeddingStatuses();
        return;
    }
    const res = await authedFetch(`/bots/${currentBotId}/config`);
    if (!res.ok) {
        applyConfigToForm();
        await loadEmbeddingStatuses();
        return;
    }
    const data = await res.json();
    applyConfigToForm(data.config || DEFAULT_CONFIG);
    await loadEmbeddingStatuses();
}

async function saveConfig() {
    if (!ensureBotSelected()) return;
    const payload = {
        embedding_model: embeddingModelSelect.value,
        chunk_size: parseIntInput(chunkSizeInput),
        chunk_overlap: parseIntInput(chunkOverlapInput),
        retrieval_top_k: parseIntInput(retrievalTopKInput),
        history_enabled: historyEnabledInput.checked,
        history_turns: parseIntInput(historyTurnsInput),
        llm_temperature: parseFloatInput(llmTemperatureInput),
        llm_top_p: parseFloatInput(llmTopPInput),
        llm_max_output_tokens: parseIntInput(llmMaxTokensInput),
        llm_repeat_penalty: parseFloatInput(llmRepeatPenaltyInput),
    };

    const res = await authedFetch(`/bots/${currentBotId}/config`, {
        method: "POST",
        headers: { "Content-Type": "application/json", ...buildAuthHeaders() },
        body: JSON.stringify(payload),
    });

    if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        alert(err.detail || "Unable to save settings.");
        return;
    }

    const data = await res.json();
    applyConfigToForm(data.config || DEFAULT_CONFIG);
    alert("Settings saved.");
}

function openPasswordDialog({ title = "Enter password", description = "", requireConfirmation = false } = {}) {
    return new Promise(resolve => {
        const overlay = document.createElement("div");
        overlay.className = "modal-overlay";

        const card = document.createElement("div");
        card.className = "modal-card";

        const heading = document.createElement("h3");
        heading.textContent = title;
        card.appendChild(heading);

        if (description) {
            const desc = document.createElement("p");
            desc.textContent = description;
            card.appendChild(desc);
        }

        const form = document.createElement("form");
        const error = document.createElement("div");
        error.className = "modal-error";
        error.style.display = "none";

        const input = document.createElement("input");
        input.type = "password";
        input.placeholder = "Password";

        const confirmInput = document.createElement("input");
        confirmInput.type = "password";
        confirmInput.placeholder = "Confirm password";
        confirmInput.style.display = requireConfirmation ? "block" : "none";

        const actions = document.createElement("div");
        actions.className = "actions";

        const cancelBtn = document.createElement("button");
        cancelBtn.type = "button";
        cancelBtn.className = "secondary";
        cancelBtn.textContent = "Cancel";

        const submitBtn = document.createElement("button");
        submitBtn.type = "submit";
        submitBtn.textContent = "Submit";

        actions.appendChild(cancelBtn);
        actions.appendChild(submitBtn);

        form.appendChild(error);
        form.appendChild(input);
        if (requireConfirmation) {
            form.appendChild(confirmInput);
        }
        form.appendChild(actions);
        card.appendChild(form);
        overlay.appendChild(card);
        document.body.appendChild(overlay);

        setTimeout(() => input.focus(), 10);

        const close = (value) => {
            overlay.remove();
            resolve(value);
        };

        cancelBtn.onclick = () => close(null);
        overlay.onclick = (e) => { if (e.target === overlay) close(null); };

        form.onsubmit = e => {
            e.preventDefault();
            const value = (input.value || "").trim();
            if (!value) {
                error.textContent = "Password is required.";
                error.style.display = "block";
                input.focus();
                return;
            }

            if (requireConfirmation) {
                const confirmation = (confirmInput.value || "").trim();
                if (confirmation !== value) {
                    error.textContent = "Passwords do not match.";
                    error.style.display = "block";
                    confirmInput.focus();
                    return;
                }
            }

            close(value);
        };
    });
}

function setPasswordFieldForBot(meta) {
    passwordEdited = false;
    if (meta?.protected) {
        passwordInput.value = "••••";
        passwordInput.dataset.masked = "true";
    } else {
        passwordInput.value = "";
        passwordInput.dataset.masked = "false";
    }
}

function findBotMeta(id) {
    return botsMeta.find(b => b.id === id);
}

async function verifyBotPassword(botId, password) {
    const res = await fetch(`/bots/${botId}/access`, {
        method: "POST",
        headers: { "Content-Type": "application/json", ...(password ? { [PASSWORD_HEADER]: password } : {}) },
        body: JSON.stringify({ password })
    });
    return res.ok;
}

async function requestPasswordForBot(botId, { forcePrompt = false } = {}) {
    if (!botId) return false;
    const meta = findBotMeta(botId);
    if (!meta || !meta.protected) {
        setBotPassword(botId, "");
        return true;
    }

    const existing = !forcePrompt ? getBotPassword(botId) : "";
    if (existing && await verifyBotPassword(botId, existing)) {
        return true;
    }

    while (true) {
        const entered = await openPasswordDialog({
            title: "Unlock bot",
            description: "This bot is private. Enter the password to continue.",
        });
        if (entered === null) {
            return false;
        }
        if (await verifyBotPassword(botId, entered)) {
            setBotPassword(botId, entered);
            return true;
        }
        alert("Incorrect password. Please try again.");
    }
}

function requestPasswordForCurrentBot(options = {}) {
    return requestPasswordForBot(currentBotId, options);
}

function appendUser(msg) {
    const wrapper = document.createElement("div");
    wrapper.className = "message user";
    wrapper.innerHTML = `<div class="label">You</div><div>${msg}</div>`;
    chat.appendChild(wrapper);
    chat.scrollTop = chat.scrollHeight;
}

function appendBotMessage(text) {
    const wrapper = document.createElement("div");
    wrapper.className = "message bot";
    wrapper.innerHTML = `<div class="label">Bot</div><div>${marked.parse(text)}</div>`;
    chat.appendChild(wrapper);
    chat.scrollTop = chat.scrollHeight;
}

function formatSecondsFromMs(value) {
    if (value === null || value === undefined) return "n/a";
    const seconds = value / 1000;
    const precision = seconds >= 10 ? 1 : 2;
    return `${seconds.toFixed(precision)} s`;
}

function formatPercentage(value) {
    if (value === null || value === undefined) return "n/a";
    return `${value.toFixed(1)}%`;
}

function renderBotMetrics(container, metrics) {
    if (!container?.metaEl || !metrics) return;
    const speed =
        metrics.tokens_per_second !== undefined && metrics.tokens_per_second !== null
            ? `${metrics.tokens_per_second.toFixed(2)} tok/s`
            : "n/a";
    const summary = [
        `LLM: ${metrics.llm_model || "unknown"}`,
        `Embed: ${metrics.embedding_model || "unknown"}`,
        `Temp: ${metrics.llm_temperature ?? "default"}`,
        `Top P: ${metrics.llm_top_p ?? "default"}`,
    ];

    const performance = [
        `Retrieval: ${formatSecondsFromMs(metrics.retrieval_ms)}`,
        `First token: ${formatSecondsFromMs(metrics.prompt_to_first_token_ms)}`,
        `Tokens: ${metrics.tokens_emitted ?? 0}`,
        `Words: ${metrics.word_count ?? 0}`,
        `Speed: ${speed}`,
        `Total: ${formatSecondsFromMs(metrics.total_time_ms)}`,
    ];

    const promptTokens =
        metrics.prompt_token_total !== undefined && metrics.prompt_token_total !== null
            ? `Prompt tokens: ${metrics.prompt_token_total} (Context ${metrics.context_token_count ?? 0} / ${formatPercentage(metrics.context_token_percentage)} • Question ${metrics.question_token_count ?? 0} / ${formatPercentage(metrics.question_token_percentage)} • System ${metrics.system_prompt_token_count ?? 0} / ${formatPercentage(metrics.system_prompt_token_percentage)} • History ${metrics.history_token_count ?? 0} / ${formatPercentage(metrics.history_token_percentage)})`
            : "";

    const metaSections = [`<div>${summary.join(" • ")}</div>`, `<div>${performance.join(" • ")}</div>`];
    if (promptTokens) {
        metaSections.push(`<div>${promptTokens}</div>`);
    }

    container.metaEl.innerHTML = metaSections.join("");
    container.metaEl.style.display = "block";
}

function renderLLMInfoBox() {
    if (!llmModelInfo) return;
    const selected = llmModelSelect.value;
    const entry = findModelEntry(availableLLMModels, selected);
    const details = entry?.details || {};
    const items = [];
    if (details.parameter_size) items.push(`Parameters: ${details.parameter_size}`);
    if (details.quantization_level) items.push(`Quantization: ${details.quantization_level}`);
    if (details.context_length) items.push(`Context window: ${details.context_length}`);

    if (!items.length) {
        llmModelInfo.style.display = "none";
        llmModelInfo.innerHTML = "";
        return;
    }

    llmModelInfo.innerHTML = `<div class="title">${selected}</div><ul>${items
        .map(item => `<li>${item}</li>`)
        .join("")}</ul>`;
    llmModelInfo.style.display = "block";
}

function describeIndexStatus(status) {
    const state = (status?.status || "empty").toLowerCase();
    if (state === "ready") {
        return status?.completed_at ? `Ready ${status.completed_at}` : "Ready";
    }
    if (state === "indexing") return "Indexing…";
    if (state === "failure") return status?.error ? `Failure (${status.error})` : "Failure";
    return "Empty";
}

function renderEmbeddingInfoBox() {
    if (!embeddingModelInfo) return;
    const selected = embeddingModelSelect.value;
    const entry = findModelEntry(availableEmbeddingModels, selected);
    const details = entry?.details || {};
    const items = [];
    if (details.embedding_length) items.push(`Dimension: ${details.embedding_length}`);
    if (details.parameter_size) items.push(`Parameters: ${details.parameter_size}`);
    if (details.quantization_level) items.push(`Quantization: ${details.quantization_level}`);

    if (!items.length) {
        embeddingModelInfo.style.display = "none";
        embeddingModelInfo.innerHTML = "";
    } else {
        embeddingModelInfo.innerHTML = `<div class="title">${selected}</div><ul>${items
            .map(item => `<li>${item}</li>`)
            .join("")}</ul>`;
        embeddingModelInfo.style.display = "block";
    }

    const status = embeddingStatuses[selected];
    if (status) {
        embeddingStatusText.textContent = describeIndexStatus(status);
        embeddingStatusText.title = status.error || "";
        embeddingStatusRow.style.display = "flex";
    } else {
        embeddingStatusRow.style.display = "none";
        embeddingStatusText.textContent = "";
        embeddingStatusText.title = "";
    }

    if (rebuildEmbeddingButton) {
        rebuildEmbeddingButton.disabled = !selected;
    }
}

function appendTyping() {
    const el = document.createElement("div");
    el.className = "message bot";
    el.innerHTML = "<div class=\"label\">Bot</div><i>Bot is typing…</i>";
    chat.appendChild(el);
    chat.scrollTop = chat.scrollHeight;
    return el;
}

function appendBotContainer() {
    const el = document.createElement("div");
    el.className = "message bot";

    const label = document.createElement("div");
    label.className = "label";
    label.textContent = "Bot";

    const content = document.createElement("div");
    content.className = "bot-content";

    const meta = document.createElement("div");
    meta.className = "bot-meta";
    meta.style.display = "none";

    el.appendChild(label);
    el.appendChild(content);
    el.appendChild(meta);

    el.rawText = "";
    el.tokenCount = 0;
    el.contentEl = content;
    el.metaEl = meta;

    chat.appendChild(el);
    chat.scrollTop = chat.scrollHeight;
    return el;
}

function renderHistoryMessages() {
    chat.innerHTML = "";
    messages.forEach(entry => {
        if (entry.role === "user") {
            appendUser(entry.content.replaceAll("\n", "<br>"));
        } else if (entry.role === "assistant") {
            appendBotMessage(entry.content);
        }
    });
}

function ensureBotSelected() {
    if (!currentBotId) {
        alert("Please create or select a bot first.");
        return false;
    }
    return true;
}

function clearChat() {
    messages = [];
    if (currentBotId) {
        botConversations[currentBotId] = messages;
    }
    chat.innerHTML = "";
}

async function sendMessage() {
    if (!ensureBotSelected()) return;

    const q = input.value.trim();
    if (!q) return;

    messages.push({ role: "user", content: q });
    botConversations[currentBotId] = messages;

    appendUser(q.replaceAll("\n", "<br>"));
    input.value = "";

    const typingEl = appendTyping();
    const removeTyping = () => { if (typingEl.parentNode) typingEl.remove(); };

    let response;
    try {
        response = await authedFetch("/ask_stream", {
            method: "POST",
            headers: {"Content-Type": "application/json", ...buildAuthHeaders()},
            body: JSON.stringify({ question: q, bot: currentBotId, history: messages })
        });
    } catch (err) {
        removeTyping();
        appendErrorMessage(`Backend request failed: ${err?.message || err}`);
        return;
    }

    if (!response.ok || !response.body) {
        removeTyping();
        appendErrorMessage(await buildErrorMessageFromResponse(response));
        return;
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buf = "";

    const botContainer = appendBotContainer();
    let pendingMetrics = null;

    try {
        while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            buf += decoder.decode(value, {stream:true});
            const lines = buf.split("\n");
            buf = lines.pop();

            for (let ln of lines) {
                if (!ln.trim()) continue;

                const event = JSON.parse(ln);

                removeTyping();

                if (event.type === "token") {
                    botContainer.rawText += event.token;
                    botContainer.tokenCount++;

                    if (botContainer.tokenCount % 5 === 0) {
                        botContainer.contentEl.innerHTML = marked.parse(botContainer.rawText);
                        chat.scrollTop = chat.scrollHeight;
                    }
                } else if (event.type === "metrics") {
                    pendingMetrics = event.metrics || null;
                }
            }
        }
    } catch (err) {
        removeTyping();
        appendErrorMessage(`Backend error while streaming: ${err?.message || err}`);
        if (botContainer.parentNode) {
            botContainer.remove();
        }
        return;
    }

    removeTyping();
    botContainer.contentEl.innerHTML = marked.parse(botContainer.rawText);
    chat.scrollTop = chat.scrollHeight;

    if (pendingMetrics) {
        renderBotMetrics(botContainer, pendingMetrics);
    }

    messages.push({ role: "assistant", content: botContainer.rawText });
    botConversations[currentBotId] = messages;
}

document.getElementById("uploadForm").onsubmit = async e => {
    e.preventDefault();
    if (!ensureBotSelected()) return;
    const form = new FormData(e.target);
    form.append("path", folderSelect.value || "");
    await authedFetch(`/bots/${currentBotId}/upload`, { method: "POST", headers: buildAuthHeaders(), body: form });
    alert("Uploaded");
    refreshFiles();
};

async function rebuild() {
    if (!ensureBotSelected()) return;
    Object.keys(embeddingStatuses || {}).forEach(model => {
        embeddingStatuses[model] = { status: "indexing" };
    });
    renderEmbeddingInfoBox();
    await authedFetch(`/bots/${currentBotId}/rebuild`, { method: "POST", headers: buildAuthHeaders() });
    alert("Reindexed!");
    await loadEmbeddingStatuses();
}

async function rebuildSelectedEmbedding() {
    if (!ensureBotSelected()) return;
    const model = embeddingModelSelect.value;
    if (!model) {
        alert("Select an embedding model first.");
        return;
    }
    embeddingStatuses[model] = { status: "indexing" };
    renderEmbeddingInfoBox();
    const res = await authedFetch(`/bots/${currentBotId}/rebuild?model=${encodeURIComponent(model)}`, {
        method: "POST",
        headers: buildAuthHeaders(),
    });
    if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        alert(err.detail || "Failed to start indexing.");
    } else {
        alert(`Rebuilding index for ${model}.`);
    }
    await loadEmbeddingStatuses();
}

function collectFolders(node, list = []) {
    if (node.path !== undefined) {
        list.push(node.path || "");
    }
    (node.folders || []).forEach(f => collectFolders(f, list));
    return list;
}

function collectFiles(node, list = []) {
    (node.files || []).forEach(f => list.push(f.path));
    (node.folders || []).forEach(f => collectFiles(f, list));
    return list;
}

function renderTree(node, container) {
    container.innerHTML = "";
    const list = document.createElement("ul");

    const renderNode = (n) => {
        const li = document.createElement("li");
        if (n.type === "folder") {
            const title = document.createElement("div");
            title.className = "folder-name";
            title.textContent = n.path ? n.name : "Root";
            if (n.path) {
                const delBtn = document.createElement("button");
                delBtn.className = "secondary";
                delBtn.textContent = "Delete";
                delBtn.onclick = () => deleteFolder(n.path);
                title.appendChild(delBtn);
            }
            li.appendChild(title);
            if ((n.folders && n.folders.length) || (n.files && n.files.length)) {
                const inner = document.createElement("ul");
                (n.folders || []).forEach(child => inner.appendChild(renderNode(child)));
                (n.files || []).forEach(file => {
                    const fileLi = document.createElement("li");
                    const nameSpan = document.createElement("span");
                    nameSpan.textContent = file.name;
                    const delBtn = document.createElement("button");
                    delBtn.className = "secondary";
                    delBtn.textContent = "Delete";
                    delBtn.onclick = () => deleteFileKB(file.path);
                    fileLi.appendChild(nameSpan);
                    fileLi.appendChild(delBtn);
                    inner.appendChild(fileLi);
                });
                li.appendChild(inner);
            }
        }
        return li;
    };

    list.appendChild(renderNode(node));
    container.appendChild(list);
}

async function refreshFiles() {
    if (!currentBotId) {
        fileTree.innerHTML = "";
        folderSelect.innerHTML = "";
        deleteFolderSelect.innerHTML = "";
        moveDestSelect.innerHTML = "";
        moveFileSelect.innerHTML = "";
        return;
    }

    const r = await authedFetch(`/bots/${currentBotId}/files`);
    const data = await r.json();
    const tree = data.tree;
    renderTree(tree, fileTree);

    const folders = collectFolders(tree, []);

    folderSelect.innerHTML = "";
    folders.forEach(path => {
        const option = document.createElement("option");
        option.value = path;
        option.textContent = path ? path : "Root (/ )";
        folderSelect.appendChild(option);
    });

    deleteFolderSelect.innerHTML = "";
    folders.filter(f => f).forEach(path => {
        const option = document.createElement("option");
        option.value = path;
        option.textContent = path;
        deleteFolderSelect.appendChild(option);
    });

    moveDestSelect.innerHTML = "";
    folders.forEach(path => {
        const option = document.createElement("option");
        option.value = path;
        option.textContent = path ? path : "Root (/ )";
        moveDestSelect.appendChild(option);
    });

    const files = collectFiles(tree, []);
    moveFileSelect.innerHTML = "";
    files.forEach(path => {
        const option = document.createElement("option");
        option.value = path;
        option.textContent = path;
        moveFileSelect.appendChild(option);
    });
}

async function deleteFileKB(name) {
    if (!ensureBotSelected()) return;
    await authedFetch(`/bots/${currentBotId}/file/${encodeURIComponent(name)}`, { method: "DELETE", headers: buildAuthHeaders() });
    alert("Deleted " + name);
    refreshFiles();
}

async function createFolder() {
    if (!ensureBotSelected()) return;
    const inputEl = document.getElementById("newFolderInput");
    const path = (inputEl.value || "").trim();
    if (!path) {
        alert("Please enter a folder path.");
        return;
    }
    await authedFetch(`/bots/${currentBotId}/folders`, {
        method: "POST",
        headers: {"Content-Type": "application/json", ...buildAuthHeaders()},
        body: JSON.stringify({ path })
    });
    inputEl.value = "";
    refreshFiles();
}

async function deleteFolder(path) {
    if (!ensureBotSelected()) return;
    const folderPath = typeof path === "string" ? path : deleteFolderSelect.value;
    if (!folderPath) {
        alert("Select a folder to delete.");
        return;
    }
    await authedFetch(`/bots/${currentBotId}/folders?path=${encodeURIComponent(folderPath)}`, { method: "DELETE", headers: buildAuthHeaders() });
    refreshFiles();
}

async function moveFile() {
    if (!ensureBotSelected()) return;
    const source = moveFileSelect.value;
    const destination_folder = moveDestSelect.value;
    if (!source) {
        alert("Select a file to move.");
        return;
    }
    await authedFetch(`/bots/${currentBotId}/move_file`, {
        method: "POST",
        headers: {"Content-Type": "application/json", ...buildAuthHeaders()},
        body: JSON.stringify({ source, destination_folder })
    });
    refreshFiles();
}

async function loadPrompt() {
    if (!currentBotId) {
        document.getElementById("systemPrompt").value = "";
        return;
    }
    const r = await authedFetch(`/bots/${currentBotId}/prompt`);
    const data = await r.json();
    document.getElementById("systemPrompt").value = data.prompt;
}

async function savePrompt() {
    if (!ensureBotSelected()) return;
    const txt = document.getElementById("systemPrompt").value;
    await authedFetch(`/bots/${currentBotId}/prompt`, {
        method: "POST",
        headers: {"Content-Type": "application/json", ...buildAuthHeaders()},
        body: JSON.stringify({ prompt: txt })
    });
    alert("Saved");
}

async function updatePassword() {
    if (!ensureBotSelected()) return;
    const meta = findBotMeta(currentBotId);
    const hasAccess = await requestPasswordForCurrentBot();
    if (!hasAccess) return;

    const hidden = hiddenCheckbox.checked;
    const payload = { hidden };

    const masked = passwordInput.dataset.masked === "true";
    const rawInput = (passwordInput.value || "").trim();
    let newPasswordValue;

    if (masked && !passwordEdited) {
        newPasswordValue = undefined;
    } else if (!rawInput) {
        if (!confirm("Remove password protection from this bot?")) {
            return;
        }
        newPasswordValue = "";
    } else {
        const confirmation = await openPasswordDialog({
            title: "Confirm new password",
            description: "Re-enter the new password to confirm.",
        });
        if (confirmation === null) {
            return;
        }
        if (confirmation !== rawInput) {
            alert("Passwords do not match. Please try again.");
            return;
        }
        newPasswordValue = rawInput;
    }

    if (typeof newPasswordValue !== "undefined") {
        payload.new_password = newPasswordValue;
    }

    const res = await authedFetch(`/bots/${currentBotId}/password`, {
        method: "POST",
        headers: {"Content-Type": "application/json", ...buildAuthHeaders()},
        body: JSON.stringify(payload)
    });

    if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        alert(err.detail || "Unable to update password.");
        return;
    }

    const data = await res.json();
    const updatedMeta = findBotMeta(currentBotId);
    if (updatedMeta) {
        if (typeof newPasswordValue !== "undefined") {
            updatedMeta.protected = !!data?.protected;
        }
        updatedMeta.hidden = !!data?.hidden;
    }

    if (typeof newPasswordValue !== "undefined") {
        setBotPassword(currentBotId, newPasswordValue);
        alert(newPasswordValue ? "Password saved." : "Password removed.");
    } else {
        alert("Settings saved.");
    }

    setPasswordFieldForBot(updatedMeta);
    hiddenCheckbox.checked = !!updatedMeta?.hidden;
}

async function loadBots() {
    const hashBotId = decodeURIComponent(window.location.hash.replace(/^#/, ""));
    const r = await fetch("/bots");
    const data = await r.json();
    botsMeta = data.bots || [];

    botSelect.innerHTML = "";

    const preferredBotId = hashBotId || currentBotId;
    const visibleBots = botsMeta.filter(bot => !bot.hidden || bot.id === preferredBotId);
    visibleBots.forEach(bot => {
        const option = document.createElement("option");
        option.value = bot.id;
        option.textContent = bot.protected ? `${bot.name} *` : bot.name;
        botSelect.appendChild(option);
    });

    botSelect.disabled = visibleBots.length === 0;

    if (!data.bots.length) {
        await switchBot(null);
        return;
    }

    if (preferredBotId && data.bots.some(bot => bot.id === preferredBotId)) {
        currentBotId = preferredBotId;
    } else if (!currentBotId || !data.bots.some(bot => bot.id === currentBotId)) {
        currentBotId = visibleBots[0]?.id || null;
    }

    botSelect.value = currentBotId;
    await switchBot(currentBotId, { force: true, requirePasswordPrompt: true });
}

async function switchBot(id, { force = false, requirePasswordPrompt = false } = {}) {
    const promptBox = document.getElementById("systemPrompt");

    if (!id) {
        currentBotId = null;
        localStorage.removeItem(BOT_STORAGE_KEY);
        messages = [];
        chat.innerHTML = "<div class=\"message bot\"><div class=\"label\">Bot</div><i>No bots available. Create one to begin.</i></div>";
        promptBox.value = "";
        fileTree.innerHTML = "";
        hiddenCheckbox.checked = false;
        setPasswordFieldForBot(null);
        applyConfigToForm();
        if (window.location.hash) {
            history.replaceState(null, "", window.location.pathname);
        }
        return;
    }

    if (!force && id === currentBotId) {
        await Promise.all([loadPrompt(), refreshFiles()]);
        renderHistoryMessages();
        return;
    }

    const previousBot = currentBotId;
    if (previousBot) {
        botConversations[previousBot] = messages;
    }
    currentBotId = id;

    const meta = findBotMeta(id);
    if (meta && meta.protected) {
        const unlocked = await requestPasswordForBot(id, { forcePrompt: requirePasswordPrompt });
        if (!unlocked) {
            currentBotId = previousBot;
            if (botSelect.value !== previousBot) {
                botSelect.value = previousBot || "";
            }
            return;
        }
    } else {
        setBotPassword(id, "");
    }

    localStorage.setItem(BOT_STORAGE_KEY, currentBotId);
    hiddenCheckbox.checked = !!meta?.hidden;
    if (botSelect.value !== id) {
        botSelect.value = id;
    }

    messages = botConversations[currentBotId] || [];
    renderHistoryMessages();
    setPasswordFieldForBot(meta);
    await Promise.all([loadPrompt(), refreshFiles(), loadConfig(), loadBotModel()]);
    if (currentBotId) {
        const targetHash = `#${encodeURIComponent(currentBotId)}`;
        if (window.location.hash !== targetHash) {
            window.location.hash = targetHash;
        }
    }
}

async function createBot() {
    const name = prompt("Name for the new bot:");
    if (!name || !name.trim()) return;

    const promptText = prompt("Optional system prompt (leave blank for default):", "");
    const passwordText = prompt("Optional password (leave blank for a public bot):", "");
    const payload = { name: name.trim() };
    if (promptText !== null && promptText.trim() !== "") {
        payload.prompt = promptText;
    }
    if (passwordText !== null && passwordText.trim() !== "") {
        payload.password = passwordText.trim();
    }
    payload.hidden = hiddenCheckbox.checked;

    const res = await fetch("/bots", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload)
    });

    if (!res.ok) {
        let detail = res.statusText;
        try {
            const err = await res.json();
            detail = err.detail || detail;
        } catch (e) {}
        alert("Failed to create bot: " + detail);
        return;
    }

    const data = await res.json();
    currentBotId = data.bot.id;
    localStorage.setItem(BOT_STORAGE_KEY, currentBotId);
    await loadBots();
    alert(`Created bot "${data.bot.name}"`);
}

async function deleteBot() {
    if (!ensureBotSelected()) return;

    const meta = findBotMeta(currentBotId);
    const label = meta ? meta.name : currentBotId;
    if (!confirm(`Delete bot "${label}"? This cannot be undone.`)) return;

    const hasAccess = await requestPasswordForBot(currentBotId, { forcePrompt: true });
    if (!hasAccess) return;

    const res = await authedFetch(`/bots/${currentBotId}`, {
        method: "DELETE",
        headers: { "Content-Type": "application/json", ...buildAuthHeaders() },
        body: JSON.stringify({ password: getBotPassword(currentBotId) })
    });

    if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        alert(err.detail || "Failed to delete bot.");
        return;
    }

    setBotPassword(currentBotId, "");
    alert("Bot deleted.");
    currentBotId = null;
    await loadBots();
}

window.addEventListener("hashchange", async () => {
    const hashBotId = decodeURIComponent(window.location.hash.replace(/^#/, ""));
    if (!hashBotId || hashBotId === currentBotId) return;
    currentBotId = hashBotId;
    await loadBots();
});

Promise.all([loadAvailableEmbeddingModels(), loadAvailableLLMModels()]).then(loadBots);
</script>
</body>
</html>
